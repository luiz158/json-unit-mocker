/**
 * Generate entites from json mocks files in the classpath
 */
package com.mageddo.json.unit.mocker;

import java.io.File;
import java.io.IOException;
import java.lang.reflect.Type;

import org.apache.commons.io.FileUtils;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.mageddo.utils.ClasshPathUtil;
import java.io.FileInputStream;
import java.io.InputStream;
import org.apache.commons.io.IOUtils;
import sun.nio.ch.IOUtil;

/**
 *
 * @author Elvis
 */
public class JsonDB {
	
	private static Gson gson = new GsonBuilder().setPrettyPrinting().create();
	private static final int DEFAULT_INDEX = 0;
	private static final String DEFAULT_EXTENSION = ".json";
	
	private JsonDB(){};
	
	public static <T> T readMock(String mockEntityName, Type type){
		try {
			return gson.fromJson(FileUtils.readFileToString(getPathInClassPath(mockEntityName)), type);
		} catch (IOException ex) {
			return null;
		}
	}
	
	@SuppressWarnings("unchecked")
	public static<T> T readMock(String mockEntityName, Class<?> type){
		try {
			return (T) gson.fromJson(FileUtils.readFileToString(getPathInClassPath(mockEntityName)), type);
		} catch (IOException ex) {
			return null;
		}
	}
	
	@SuppressWarnings("unchecked")
	public static String readAsString(String mockEntityName){
		try {
			return FileUtils.readFileToString(getPathInClassPath(mockEntityName));
		} catch (IOException ex) {
			return null;
		}
	}
	
	@SuppressWarnings("unchecked")
	public static InputStream readAsStream(String mockEntityName){
		try {
			return new FileInputStream(getPathInClassPath(mockEntityName));
		} catch (IOException ex) {
			return null;
		}
	}
	
	@SuppressWarnings("unchecked")
	public static File readAsFile(String mockEntityName){
		return getPathInClassPath(mockEntityName);
	}
	
	/**
	 * Deserialize the object from the json file
	 * @param mockEntityFile the json file
	 * @param type the type to deserialize
	 * @return the deserialized object
	 */
	@SuppressWarnings("unchecked")
	public static<T> T readMock(File mockEntityFile, Class<?> type){
		try {
			return (T) gson.fromJson(FileUtils.readFileToString(mockEntityFile), type);
		} catch (IOException ex) {
			return null;
		}
	}
	
	/**
	 * 
	 * @param fileName
	 * @return the relative path to the specified file name
	 */
	protected static File getPathInClassPath(String fileName) {
		return new File(getDefaultFolder(), fileName + DEFAULT_EXTENSION);
	}

	/**
	 * Return the default path to save the json file
	 * @return
	 */
	public static File getDefaultFolder() {
		return ClasshPathUtil.getInstance()
				.getPath(DEFAULT_INDEX);
	}

	/**
	 * 
	 * @param o the object class
	 * @return the name to the serialized entity of that class
	 */
	public static String getDefaultMockFileName(Class<?> o) {
		return o.getName() + DEFAULT_EXTENSION;
	}

	/**
	 * Write the mock of object as json file with the path and name generated by {@link #getDefaultFolder()} {@link #getDefaultMockFileName(Class)} 
	 * @param o object to save
	 * @throws IOException
	 */
	public static void writeMock(Object o) throws IOException{
		FileUtils.write(getPathInClassPath(getDefaultMockFileName(o.getClass())), gson.toJson(o));
		
	}
	
	/**
	 * Write the mock of object as json
	 * @param o the object to save
	 * @param mockName  the name of the object, also can be used relative path eg. mocks/mock <b>the extension is put in, automatically</b>
	 * @throws IOException
	 */
	public static void writeMock(Object o, String mockName) throws IOException{
		FileUtils.write(getPathInClassPath(mockName), gson.toJson(o));
	}
	
	/**
	 * Write the mock of object as json
	 * @param o the object to save
	 * @param mockFile the file to save
	 * @throws IOException
	 */
	public static void writeMock(Object o, File mockFile) throws IOException{
		FileUtils.write(mockFile, gson.toJson(o));
	}

	/**
	 * Allows to subscribe another gson serializer with different rules for example.
	 * @param gson
	 */
	public void setSerializer(Gson gson){
		JsonDB.gson = gson;
	}
}
